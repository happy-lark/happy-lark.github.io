---
layout: single
title: 개념정리(1~4) 
---

**01 자료구조 (p22~46)**

**자료구조란?**
: 입력으로 들어온 데이터들을 저장하는 도구
: (기본 라이브러리로 주어지는 자료구조 활용하기!) <br> 
**배열 (Array)**
: 대부분의 프로그래밍 언어에서 제공하는 기본 자료구조 <br>
: 배열 만들면 > 값을 담을 공간을 메모리에 *연속적*으로 할당해줌 <br>
: 시간 복잡도: O(1) <br>
: -단점 <br>
1. 데이터 삽입/삭제 속도가 느림 <br>
:삽입/삭제 시간 복잡도: O(N)<br>
2. 크기 고정 및 변경 불가<br>
(C++: vector 사용 시 해결/ Python: 리스트로 변경 가능) <br>

**연결 리스트 (Linked List)** <br>
장점 <br>
1.메모리 상 빈 공간들 활용 good~ <br>
(각각의 노드는 다음 노드가 위치한 주소 값을 가지고 있어야 함) <br>
2. 삽입/삭제 빠름<br>
-삽입/ 삭제 시간 복잡도: O(1) <br>
3.크기 변경 자유로움 <br>

단점 <br>
1.index 통한 임의 접근 X <br>
:조회 시간 복잡도 O(N) <br>
>배열보다 느림.. <br>

**배열 VS 연결 리스트** <br>
삽입/삭제 적고, 조회 많은 상황: 배열 <br>
VS <br>
삽입/삭제 많고, 조회 적은 상황: 연결 리스트<br>
 
-알고리즘 문제: 배열 더 자주 활용<br>
-둘이 *상반된* 특징을 가지고 있다는 점에서 면접에서 비교 질문 많이 나옴 <br>

**완전탐색 (p47~58)** <br>

**완점탐색이란?** <br>
:’답을 찾기 위해 모든 경우를 다 살펴본다는 전략’ <br>

장점: 확실하게 답을 찾을 수 있음 <br>
단점: 시간이 오래 걸림 <br>

이때, 컴퓨팅 자원과 시간은 trade-off 관계 /n
(더 빠르고 많은 컴퓨터 사용 > 시간 단축 /n
컴퓨터 덜 사용 > 시간 증가)  /n

**브루트 포스 (Brute Force)** /n
-’무차별 대입’ /n
-완점탐색 전략을 충실히 활용하는 방식 /n
-반복문/ 재귀/ 순열, 조합으로 풀이 /n

**순열 (Permutation)** /n
-C++: next_permutation (STL)으로 쉽게 순열 구할 수 있음/n
-Python: itertools의 permutations을 import 후 사용 /n

**조합 (Combination)** /n
-C++: 따로 조합 STL X > next_permutation을 이용 OR 재귀함수로 구현 /n
-Python: itertools의 combinations를 import 후 사용 /n

**탐욕법 (p59 ~ 66)** /n

**탐욕법 (탐욕 알고리즘/ Greedy Algorithm)?** /n
: 현재 상태에서 최선 (quickest)의 상태만 선택하는 알고리즘 /n

-완전탐색과 달리, 모든 경우를 보지 X -> 완전탐색보다 빠름 /n
-문제에서 규칙성만 파악하면 풀이 가능 (단, 풀이법을 생각해내는 게 어려울 뿐..) /n
-문제가 그리디(Greedy) 문제인지 판별하는 것과 반례가 없는 올바른 아이디어인지 판단하는 것이 중요함 /m

**DFS, BFS 백트래킹 (p67 ~ 92)** /n

DFS, BFS, 백트래킹을 풀기 위해서는 그래프와 트리에 대해 알아야 된다. /n

그래프 (Graph) /n
: 그래프= 노드 (Node, Vertex) + 간선 (Edge) /n

그래프의 방향성 /n
1.방향 그래프: 방향성 O  /n
2. 무방향 그래프: 방향성 X (=양방향 그래프: 방향성이 없다는 건 어느 쪽으로도 갈 수 있다는 의미!) /n

그래프의 순환성 /n
1.순환 그래프 (Cyclic): 순환하는 부분이 한 군데만 있어도 순환 그래프 /n
2.비순환 그래프 (Acyclic) /n

cf. 방향성 비순환 그래프 = DAG (Directed Acyclic Graph) /n
> git 같은 버전 관리 시스템 (Version Control System)의 브랜치는 주로 DAG로 이루어짐 /n
> why? commit 기록은 시간이 지나며 쌓임 > 시간은 한 방향으로만 흐름 + 다시 돌아갈 수  X > 사이클 X /n

그래프의 연결 요소 /n

트리 (Tree) /n
-순환성 X, 무방향 그래프  /n

Leaf node, root /n

노드 A에서 노드 B로 가는 경로는 반드시 존재 + 유일 /n
노드 개수 = 간선 개수 + 1 /n

이때! 계층이 있는 트리도 사용  /n
-> 루트 노드 1개 + 부모-자식 관계 존재 (상위 노드: 부모/ 하위 노드: 자식) /n

그래프를 코드로 나타내는 방법 /n
1.인접 행렬 (Adjacency Matrix) /n
2.인접 리스트 (Adjacency List) /n

DFS (Depth First Search) /n
-’깊이 우선 탐색’ /n
-그래프 탐색 알고리즘 중 하나 /n
-어떤 노드에서 시작 > 답을 찾을 때까지 갈 수 있는 인접 노드가 존재한다면 그 노드로 탐색 반복 (계속해서 깊게 파고 내려가는 형태) > if. 더 이상 진행할 인접 노드 X > 올라와서 또 다시 다른 인접 노드로 탐색 진행 /n

-스택/ 재귀함수로 구현 (일반적으로 더 편한 재귀 함수 사용) /n
 
BFS (Breadth First Search) /n
-’너비 우선 탐색’ /n
-그래프 탐색 알고리즘 중 하나 /n
-!DFS와 탐색 순서 차이 존재! /n
-현재 노드에서 모든 인접 노드 탐색 > 아래 계층으로 내려감 /n
-최단거리 구할 때 good /n
-큐로 구현 /n

DFS VS BFS /n
-DFS, BFS 모두 완전 탐색 알고리즘 /n
-둘 다 최단거리 구할 수 있음  (but 최단거리 탐색을 해야 할 경우, BFS 사용) /n

시간복잡도 /n
-인접 행렬/ 인접 리스트를 썼을 때 다름 /n
-정점 개수: V / 간선 개수: E /n
-DFS, BFS 시간 복잡도는 /n
인접행렬: O(V^2) /n

(순열 조합을 알아두면 완점탐색, 경우의 수 문제를 쉽게 풀 수 있음 /n
삼성 코테에서 순열 조합을 이용하는 문제 자주 출제됨!) 


